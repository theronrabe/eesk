{"name":"Eesk","tagline":"The unsafe programming language","body":"# The Eesk Programming Language\r\n\r\n***\r\n\r\n### Eesk in concept\r\nEesk is a programming language designed with the following philosophies in mind:\r\n* Even gibberish can have an intended meaning. Any string of ascii characters is a valid Eesk program.\r\n* A programming environment should not prevent its users from doing stupid things. Just because a program doesn't make sense from a compiler's point of view, doesn't mean it contains mistakes.\r\n* Since all types are ultimately composed of bits, types should be as interchangeable as bits. The type of a symbol should be determined by the context it is used in, rather than how it was declared. Abstraction should not prevent computation.\r\n* High-level concepts in a language should not hide their underlying mechanics from the programmer. In other words, the architecture should be easy to abuse.\r\n***\r\n\r\n### How to use Eesk software\r\nTo execute your Eesk programs, you will need two programs installed on your computer: ee and eesk. Download links can be found at the top of this page. Text files containing Eesk programs can be compiled by issuing the command:\r\n\r\n```\r\n\t$ ./ee example.ee\r\n```\r\n\r\nee will then place an eesk-able translation of the instructions into the file e.out. To use eesk, give it the path to a compiled file:\r\n\r\n```\r\n\t$ ./eesk e.out [-v]\r\n```\r\n\r\nThe program will be executed and its results will be depicted as values on a stack, in hexadecimal. Optionally, with the -v flag set, the instruction-by-instruction actions of the virtual machine will display. Note that this dramatically slows the performance of eesk.\r\n***\r\n\r\n### Hello, World!\r\nTo begin using Eesk, take a look at a simple example program, manual_examples/prints.ee:\r\n\r\n```haskell\r\n#This program prints some text\r\n{\r\nBegin\r\n\tprints “You're a grapefruitses.\\n”;\r\nEnd\r\n}\r\n```\r\n\r\nUpon analysis, you might correctly assume that the # symbol leading the first line is indicative of a comment. Any text between a # and a new line will be ignored by ee. This, along with symbol delimiting, are the only times whitespace characters affect the meaning of an Eesk statement.\r\n\r\nThe { on the second line is negligible; it has no meaning and is placed there solely for aesthetic symmetry with the closing }.\r\n\r\nThe Begin keyword on the third line indicates that the virtual machine should begin executing instructions at this location. Each symbol (separated by whitespace), with the exception of a few keywords, represents a location in eesk's memory. This memory location is determined by where the most recent declaration of the symbol in the Eesk file was, where “recency” could be measured as increasing from the beginning toward the end of the file. Note that “declaration” is a loose term in Eesk, as it could simply be an unexpected first use of a new symbol in the middle of a subroutine. Opposite of the Begin keyword is End. End halts the eesk virtual machine at the current location.\r\n\r\nAt the heart of the program is the prints operator, a string (which could by anything between a pair of “), and a ;.\r\n\r\nprints is an operator. To understand what an operator is in Eesk, you must understand the architecture of  Eesk. Eesk is composed of statements, each of which defines how various operands should be pushed onto a stack, what operations should be performed on the top of the stack, and how values should be removed from the stack. A statement may contain any combination of characters, and is terminated by a  }. When an operator is encountered, it is remembered until the next ;, =, <, >, &, |, }, ), ], or ',' is encountered. At that time, all the remembered operators are released for eesk to execute on the stack. This is done at compile time.\r\n***\r\n\r\n### The Stack\r\nThe string in the previous code is an example of one of the operands that occupy the stack. Anything that is not an operator or a keyword is an operand, and it will be pushed to the stack simply because it is encountered. From this, you can gather what the following Eesk statement means, from manual_examples/theStack.ee:\r\n```lua\r\n#This program illustrates manipulation of the stack\r\n{\r\nBegin\r\n        3 - 2 + 1;\r\n        - + 3 2 1;\r\n        3 2 - + 1;\r\n        3 2 1 - +;\r\nEnd\r\n}\r\n```\r\nWhen you run this program, you'll see an output of four 0s depicted on a stack. That is because all four lines between Begin and End mean the same thing. They place a 3, a 2, and a 1 on the stack, then perform an addition followed by a subtraction. These binary operators are right-associative, so the repeated line could more concretely be written as (3 – (2 + 1)).\r\n***\r\n\r\n### Symbols\r\nAn Eesk statement may use custom symbols as operands; from manual_examples/symbol.ee:\r\n```eiffel\r\n#This program defines a symbol\r\n{\r\n        given message\r\nBegin   \r\n        message = \"We've made a symbol!\\n\";\r\n        prints message$;\r\nEnd     \r\n}\r\n```\r\nThe “given” keyword indicates that the current relative location should correlate to a word of memory that is known as the following symbol. Whenever that symbol is found again, it means to place the correlated address to the stack. When the = operator is encountered in the example, then, the “message” address is assigned the value of the address correlated to the following string. Later, when the “message” symbol is again pushed to the stack, its contents are retrieved via $. Note that it is valid Eesk to remove the “given message” line. Doing so would delay the declaration of “message” until its next encounter (which changes its location in eesk's memory space), but has a virtually identical meaning.\r\n\r\nTo further show how implicit symbols could be used, look at manual_examples/implicit.ee:\r\n```\r\n#This program uses implicitly-defined symbols\r\n{\r\nBegin\r\n        myVal1 = 12;\r\n        myVal2 = myVal1$ + 1;\r\n        myVal3 = myVal1$ + myVal2$;\r\n        \r\n        myVal3$;\r\nEnd\r\n}\r\n```\r\nWhen you compile this, ee will remind you of your implicit declarations (in case you were to accidentally make one). The program Ends after leaving the contents of myVal3 on the stack, which is correctly calculated as 19 (results in hexadecimal, Eesk code in decimal).\r\n***\r\n\r\n### Control Structures\r\nEesk is a structured language. Decision and iteration are done via “if” and “while” directives. An example is found in manual_examples/structure.ee:\r\n```\r\n#This program uses control structures\r\n{\r\nBegin\r\n        while {i$ < 20} {\r\n                if {i$ % 2} {\r\n                        printd i$;\r\n                } {     \r\n                        prints \"not odd\\n\";\r\n                }       \r\n                \r\n                i = i$ + 1;\r\n        }       \r\nEnd     \r\n}\r\n```\r\nThis program counts the implicit symbol “i” up to 19, printing the value of the odds, or some text for the evens. You'll notice that the while directive takes two statements as parameters (because it is followed by two groups of {}, and } ends a statement), exactly. The first parameter statement is a condition that, while met, will allow the second parameter statement (the body) to be repeatedly executed. The if directive takes exactly three parameter statements: a condition, a true, and a false statement. If the condition evaluates to non-zero, the true statement is executed, otherwise the false statement is.\r\n***\r\n\r\n### Functions\r\nEesk instructions can be reused with the help of the Function directive. An Eesk function has a block-structured calling convention for passing arguments and storing local variables, a chunk of non-block-structured function memory for local storage (making it a versatile form of subroutine), and a statement of instructions to execute when called. An example program using functions can be found in manual_examples/functions.ee:\r\n```\r\n#This program uses the Function directive\r\n{\r\n        Function twoXplusY {A, B} { \r\n                private Function add {X, Y} {} {\r\n                        return (X$ + Y$);\r\n                } \r\n        }{      \r\n                return add[2*A$, B$];\r\n        }\r\nBegin\r\n        X = 34;\r\n        Y = 3;\r\n        twoXplusY[X$, Y$];\r\nEnd\r\n}\r\n```\r\nYou can see two function definitions in this program. The first function twoXplusY, is given two symbols (A and B) of data on the activation stack (which the function can optionally take as arguments). It has another function, add, defined in its static memory. The private flag is used here to prevent Eesk code outside of the parent function from accessing it via twoXplusY.add, as could be done were a “public” flag set. When the public flag is set, any symbols declared before the next ; are accessible beyond their scope by means of the '.' operator. This will be covered more later in this manual.\r\n\r\nA function can be called by means of the [] pair of operators, which call the function located at whatever address is on top of the stack. Any time a , is encountered (or ] with symbols preceding it) the value atop the stack is added to the activation stack, thus passing it as an argument. A function can, however, be called with more or fewer arguments than requested by the function definition.\r\n\r\nThe return operator pops the stack, then returns to the address now atop the stack, pushing the first-popped value back on to the stack. In effect, it terminates execution of the function and returns its most recently-computed value. Control is returned to where the call was made. The default return value for a function is its own calling address.\r\n\r\nSince each function is a symbol, it can be spontaneously and implicitly declared just like any other symbol. This makes Eesk functions usable as a lambda calculus. An example of function versatility is demonstrated by the program found in manual_examples/implicitFunctions.ee:\r\n```\r\n#This program uses implicit function declaration \r\n{\r\nBegin\r\n        Function inc {x} {} {x$ = x$$ + 1}[x][][][][][][][][][]^;\r\n        x$;\r\nEnd     \r\n}\r\n```\r\nThis program implicitly declares a function inc, which takes an argument that is effectively used as a pointer, and increments the value stored there. The function declares no static memory, so an empty pair of {} is found between the parameter statement and the body statement in place of a data statement. The implicit symbol declaration leaves its correlated address on the stack (the calling address for the function, in this case), which is then called with [x]. This is the first encountering of x in this scope, so it is implicitly declared. This declaration in the first set of [] passes its own address to inc. The symbol x is now incremented. inc by default returns its own calling address. Because of this, it can be immediately re-called without any arguments, which means the function assumes whatever arguments were most recently contained in the unprovided parameter (still x).\r\n\r\nAt the end of the line with the implicit function declaration is a ^. This operator pops the stack, disregarding its value. In the provided example, it is used to remove the address correlated to inc from the stack.\r\n***\r\n\r\n### Collections and Fields\r\nAn additional useful construct of Eesk is the Collection. A collection in Eesk is similar to a class in Java. It is a set of symbols and instructions addressed relative to itself, so that it can be duplicated into functionally-independent objects. Any copy of a collection has its own private and public symbols. Its private symbols are only accessible within its own scope, whereas the public symbols are available to outsiders through a pointer to the object. An example can be found in manual_examples/collections.ee:\r\n```\r\n#This program uses collections\r\n{\r\n        Collection data {\r\n                private given a;\r\n                public given b;\r\n\r\n                public Function add {} {} {\r\n                        return a$ + b$;\r\n                }\r\n                public Function setA {i} {} {\r\n                        a = i$;\r\n                        return a$;\r\n                }\r\n        }\r\n\r\nBegin\r\n        myData = new data;\r\n\r\n        myData->data.setA[5]^;\r\n        myData->data.b = 3;\r\n\r\n        myData2 = new myData$;\r\n        myData2->data.add[];\r\n\r\n        free myData$;\r\n        free myData2$;\r\nEnd\r\n}\r\n```\r\nThis program defines a collection, data. Data has one private symbol and three public symbols (the last two being functions). In order to generate a copy of data in memory, the new operator is used. This operator duplicates the memory found at the address atop the stack, and results in a pointer to the new copy. The free operator undoes this allocation. The implicit symbol myData, then, contains the address to a copy of data. Public symbols of the collection are correlated to the symbols data.b, data.add, and data.setA. These symbols are the relative offset from the beginning of their collection, so they can be later added to a collection pointer to access the elements within an object. This is what the “->” operator does; it adds the next encountered offset to the pointer atop the stack. So in this example, myData contains a pointer to a new copy of data, and myData->data.setA adds the offset associated to data.setA to the pointer myData left on the stack.\r\n\r\nEesk has a static alternative to the collection: the Field. The Field directive defines a section of memory with it's own private and public symbols that only has a single copy, and is not new-able. To see a Field in action, take a look at manual_examples/field.ee:\r\n```\r\n#This program uses a Field directive\r\n{\r\n        Field math {\r\n                private given result\r\n                \r\n                public Function add {x} {} {\r\n                        result = result$ + x$;\r\n                }       \r\n                \r\n                public Function subtract {x} {} {\r\n                        result = result$ - x$;\r\n                }       \r\n\r\n                public Function getResult {} {} {\r\n                        return result$;\r\n                }\r\n        }       \r\nBegin\r\n        math.add[3][4][5]^;\r\n        math.getResult[];\r\n\r\n        math.subtract[6][1]^;\r\n        math.getResult[];\r\nEnd     \r\n}\r\n```\r\nField directives can easily be used as an alternative to C's “enum”. They are also a good way to implement libraries, particularly when aided by the include directive. Look to manual_examples/include.ee:\r\n```\r\n#This program includes external Eesk statements to use their Fields\r\n{\r\n        include \"system.IO\"\r\n        include \"system.string\"\r\n\r\n        define myString \\\"a cdef\"\\\r\n        given 8 msg;\r\nBegin\r\n        myString+1 set 'b;\r\n        string.strcat[myString, \" 123456\"]^;\r\n        IO.puts[myString]^;\r\nEnd\r\n}\r\n```\r\nThe include directives on lines 3 and 4 delay the continued compilation of the current file until the file found at “include/<file in quotes>.ee” is compiled into the output. Since these included files contain fields full of symbols, those symbols are now accessible within the current scope. The “system” library is eesk's connection to the C standard library and the underlying operating system.\r\n\r\nAny symbols delimited by \\ symbols will be written to that location in the output file value by value, instead of being first interpreted as Eesk. In this case, since the string “a cdef” is between backslashes, the address for the string will not be pushed to the stack, instead the output file literally contains the that text. The define directive gives that current location a symbol (myString). The given directive can be given a number as its first parameter, which allows the symbol msg to consume 8 words of memory, like an array. As used in this example, it ensures that myString points to enough memory to contain a longer concatenated string.\r\n\r\nOther new operators in this example are set, which is the byte-size equivalent of =; and ', which places the following character onto the stack.\r\n***\r\n\r\n### Linking Eesk\r\nTo better understand the system library and how it communicates with the native operating system, take a look at part of include/system.IO.ee:\r\n```\r\n{        \r\n\tpublic Field IO {\r\n                private given libc\r\n                private define libPath  \\\"libc.so.6\"\\\r\n        \r\n                public Function init {} {} {libc = load libPath}\r\n        \r\n                global public Function putc {given c} {\r\n                        private Native call \"putchar:v(c)\";\r\n                } {\r\n                        if {libc$!} {init[]^} {}\r\n                        call@libc$[c$]^;\r\n                }\r\n        }\r\n}\r\n```\r\nThe library works by providing the name of a shared object file, and using the load operator to bring it into use. Once it has done so, the funtion putc can call a subroutine within that shared object. To do so, it uses a Native construct.  A Native construct is given a symbol, and string that contains a subroutine name, a return type, and a number/type of parameters. It is compiled into a structure of data that contains everything it needs to be resolved and executed at runtime. In order to make that call, place a Native symbol on the stack, along with the loaded shared object, and use []. In order to differentiate this type of call from a normal function call, use the @ symbol.\r\n***\r\n\r\n### Literal Eesk\r\nFor a more illustrative example of how \\ works that ties together nicely with other previously mentioned Eesk concepts, take a look at manual_example/operatorSwap.ee:\r\n```\r\n#This program uses literal operators\r\n{       \r\n        Function do {x,y} {} {\r\n                return x$ y$ \\public operator\\;\r\n        }\r\n                \r\n        define plus +;\r\n        define minus -;\r\nBegin                   \r\n        do.operator = plus$;\r\n        do[1,2];\r\n                        \r\n        do.operator = minus$;\r\n        do[1,2];\r\nEnd             \r\n}          \r\n```\r\nThis program defines a function do, that places its first and second arguments on the stack, then does something to them before returning. That something is publicly labeled “operator” and since it is between two backslashes, it is not pushed to the stack; it is encountered as an instruction by the virtual machine when do is called. Since the literal values for + and – operators are also known, they can be assigned to do's operator symbol. Without backslashes, symbols only have the power to modify other operand symbols. With backslashes, any Eesk construct can be modified to be used as a symbol, even operators.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}